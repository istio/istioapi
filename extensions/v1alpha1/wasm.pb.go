// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: extensions/v1alpha1/wasm.proto

package v1alpha1

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	v1beta1 "istio.io/api/type/v1beta1"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// The phase in the filter chain where the plugin will be injected.
type PluginPhase int32

const (
	// Control plane decides where to insert the plugin. This will generally
	// be at the end of the filter chain, right before the Router.
	// Do not specify `PluginPhase` if the plugin is independent of others.
	PluginPhase_UNSPECIFIED PluginPhase = 0
	// Insert plugin before Istio authentication filters.
	PluginPhase_AUTHN PluginPhase = 1
	// Insert plugin before Istio authorization filters.
	PluginPhase_AUTHZ PluginPhase = 2
	// Insert plugin before Istio stats filters.
	PluginPhase_STATS PluginPhase = 3
)

var PluginPhase_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "AUTHN",
	2: "AUTHZ",
	3: "STATS",
}

var PluginPhase_value = map[string]int32{
	"UNSPECIFIED": 0,
	"AUTHN":       1,
	"AUTHZ":       2,
	"STATS":       3,
}

func (x PluginPhase) String() string {
	return proto.EnumName(PluginPhase_name, int32(x))
}

func (PluginPhase) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4d60b240916c4e18, []int{0}
}

// The pull behaviour to be applied when fetching an OCI image,
// mirroring K8s behaviour.
//
// buf:lint:ignore ENUM_VALUE_UPPER_SNAKE_CASE
type PullPolicy int32

const (
	// If an existing version of the image has been pulled before, that
	// will be used. If no version of the image is present locally, we
	// will pull the latest version.
	PullPolicy_IfNotPresent PullPolicy = 0
	// We will always pull the latest version of an image when applying
	// this plugin.
	PullPolicy_Always PullPolicy = 1
)

var PullPolicy_name = map[int32]string{
	0: "IfNotPresent",
	1: "Always",
}

var PullPolicy_value = map[string]int32{
	"IfNotPresent": 0,
	"Always":       1,
}

func (x PullPolicy) String() string {
	return proto.EnumName(PullPolicy_name, int32(x))
}

func (PullPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4d60b240916c4e18, []int{1}
}

// WasmPlugins provides a mechanism to extend the functionality provided by
// the Istio proxy through WebAssembly filters.
//
// <!-- crd generation tags
// +cue-gen:WasmPlugin:groupName:extensions.istio.io
// +cue-gen:WasmPlugin:version:v1alpha1
// +cue-gen:WasmPlugin:storageVersion
// +cue-gen:WasmPlugin:annotations:helm.sh/resource-policy=keep
// +cue-gen:WasmPlugin:labels:app=istio-pilot,chart=istio,heritage=Tiller,release=istio
// +cue-gen:WasmPlugin:subresource:status
// +cue-gen:WasmPlugin:scope:Namespaced
// +cue-gen:WasmPlugin:resource:categories=istio-io,extensions-istio-io
// +cue-gen:WasmPlugin:preserveUnknownFields:pluginConfig
// +cue-gen:WasmPlugin:printerColumn:name=Age,type=date,JSONPath=.metadata.creationTimestamp,description="CreationTimestamp is a timestamp
// representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations.
// Clients may not set this value. It is represented in RFC3339 form and is in UTC.
// Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata"
// -->
//
// <!-- go code generation tags
// +kubetype-gen
// +kubetype-gen:groupVersion=extensions.istio.io/v1alpha1
// +genclient
// +k8s:deepcopy-gen=true
// -->
type WasmPlugin struct {
	// Criteria used to select the specific set of pods/VMs on which
	// this plugin configuration should be applied. If omitted, this
	// configuration will be applied to all workload instances in the same
	// namespace.  If omitted, the `WasmPlugin` will be applied to all
	// workloads in the same namespace. If the `WasmPlugin` is
	// present in the config root namespace, it will be applied to all
	// applicable workloads in any namespace.
	Selector *v1beta1.WorkloadSelector `protobuf:"bytes,1,opt,name=selector,proto3" json:"selector,omitempty"`
	// URL of a Wasm module or OCI container. If no scheme is present,
	// defaults to `oci://`, referencing an OCI image. Other valid schemes
	// are `file://` for referencing .wasm module files present locally
	// within the proxy container, and `http[s]://` for .wasm module files
	// hosted remotely.
	Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	// Types that are valid to be assigned to XSha256:
	//	*WasmPlugin_Sha256
	XSha256 isWasmPlugin_XSha256 `protobuf_oneof:"_sha256"`
	// The pull behaviour to be applied when fetching an OCI image. Only
	// relevant when images are referenced by tag instead of SHA. Defaults
	// to IfNotPresent, except when an OCI image is referenced in the `url`
	// and the `latest` tag is used, in which case `Always` is the default,
	// mirroring K8s behaviour.
	// Setting is ignored if `url` field is referencing a Wasm module directly
	// using `file://` or `http[s]://`
	ImagePullPolicy PullPolicy `protobuf:"varint,4,opt,name=image_pull_policy,json=imagePullPolicy,proto3,enum=istio.extensions.v1alpha1.PullPolicy" json:"image_pull_policy,omitempty"`
	// Credentials to use for OCI image pulling.
	// Name of a K8s Secret in the same namespace as the `WasmPlugin` that
	// contains a docker pull secret which is to be used to authenticate
	// against the registry when pulling the image.
	ImagePullSecret string `protobuf:"bytes,5,opt,name=image_pull_secret,json=imagePullSecret,proto3" json:"image_pull_secret,omitempty"`
	// Public key that will be used to verify signatures of signed OCI images
	// or Wasm modules. Must be supplied in PEM format.
	VerificationKey string `protobuf:"bytes,6,opt,name=verification_key,json=verificationKey,proto3" json:"verification_key,omitempty"`
	// The configuration that will be passed on to the plugin.
	PluginConfig *types.Struct `protobuf:"bytes,7,opt,name=plugin_config,json=pluginConfig,proto3" json:"plugin_config,omitempty"`
	// The plugin name to be used in the Envoy configuration (used to be called
	// `rootID`). Some .wasm modules might require this value to select the Wasm
	// plugin to execute.
	PluginName string `protobuf:"bytes,8,opt,name=plugin_name,json=pluginName,proto3" json:"plugin_name,omitempty"`
	// Determines where in the filter chain this `WasmPlugin` is to be injected.
	Phase PluginPhase `protobuf:"varint,9,opt,name=phase,proto3,enum=istio.extensions.v1alpha1.PluginPhase" json:"phase,omitempty"`
	// Determines ordering of `WasmPlugins` in the same `phase`.
	// When multiple `WasmPlugins` are applied to the same workload in the
	// same `phase`, they will be applied by priority, in descending order.
	// If `priority` is not set, or two `WasmPlugins` exist with the same
	// value, the ordering will be deterministically derived from name and
	// namespace of the `WasmPlugins`.
	Priority             *types.Int64Value `protobuf:"bytes,10,opt,name=priority,proto3" json:"priority,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *WasmPlugin) Reset()         { *m = WasmPlugin{} }
func (m *WasmPlugin) String() string { return proto.CompactTextString(m) }
func (*WasmPlugin) ProtoMessage()    {}
func (*WasmPlugin) Descriptor() ([]byte, []int) {
	return fileDescriptor_4d60b240916c4e18, []int{0}
}
func (m *WasmPlugin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WasmPlugin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WasmPlugin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WasmPlugin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WasmPlugin.Merge(m, src)
}
func (m *WasmPlugin) XXX_Size() int {
	return m.Size()
}
func (m *WasmPlugin) XXX_DiscardUnknown() {
	xxx_messageInfo_WasmPlugin.DiscardUnknown(m)
}

var xxx_messageInfo_WasmPlugin proto.InternalMessageInfo

type isWasmPlugin_XSha256 interface {
	isWasmPlugin_XSha256()
	MarshalTo([]byte) (int, error)
	Size() int
}

type WasmPlugin_Sha256 struct {
	Sha256 string `protobuf:"bytes,3,opt,name=sha256,proto3,oneof" json:"sha256,omitempty"`
}

func (*WasmPlugin_Sha256) isWasmPlugin_XSha256() {}

func (m *WasmPlugin) GetXSha256() isWasmPlugin_XSha256 {
	if m != nil {
		return m.XSha256
	}
	return nil
}

func (m *WasmPlugin) GetSelector() *v1beta1.WorkloadSelector {
	if m != nil {
		return m.Selector
	}
	return nil
}

func (m *WasmPlugin) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *WasmPlugin) GetSha256() string {
	if x, ok := m.GetXSha256().(*WasmPlugin_Sha256); ok {
		return x.Sha256
	}
	return ""
}

func (m *WasmPlugin) GetImagePullPolicy() PullPolicy {
	if m != nil {
		return m.ImagePullPolicy
	}
	return PullPolicy_IfNotPresent
}

func (m *WasmPlugin) GetImagePullSecret() string {
	if m != nil {
		return m.ImagePullSecret
	}
	return ""
}

func (m *WasmPlugin) GetVerificationKey() string {
	if m != nil {
		return m.VerificationKey
	}
	return ""
}

func (m *WasmPlugin) GetPluginConfig() *types.Struct {
	if m != nil {
		return m.PluginConfig
	}
	return nil
}

func (m *WasmPlugin) GetPluginName() string {
	if m != nil {
		return m.PluginName
	}
	return ""
}

func (m *WasmPlugin) GetPhase() PluginPhase {
	if m != nil {
		return m.Phase
	}
	return PluginPhase_UNSPECIFIED
}

func (m *WasmPlugin) GetPriority() *types.Int64Value {
	if m != nil {
		return m.Priority
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*WasmPlugin) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*WasmPlugin_Sha256)(nil),
	}
}

func init() {
	proto.RegisterEnum("istio.extensions.v1alpha1.PluginPhase", PluginPhase_name, PluginPhase_value)
	proto.RegisterEnum("istio.extensions.v1alpha1.PullPolicy", PullPolicy_name, PullPolicy_value)
	proto.RegisterType((*WasmPlugin)(nil), "istio.extensions.v1alpha1.WasmPlugin")
}

func init() { proto.RegisterFile("extensions/v1alpha1/wasm.proto", fileDescriptor_4d60b240916c4e18) }

var fileDescriptor_4d60b240916c4e18 = []byte{
	// 515 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x93, 0xdf, 0x6e, 0x12, 0x41,
	0x14, 0xc6, 0xd9, 0x52, 0x28, 0x1c, 0xaa, 0x5d, 0xe7, 0xc6, 0xb5, 0x18, 0x24, 0x46, 0x0d, 0x72,
	0x31, 0x1b, 0x50, 0xeb, 0x4d, 0x13, 0xa5, 0xb5, 0xa6, 0xc4, 0x84, 0xac, 0xbb, 0xd4, 0x26, 0xbd,
	0x21, 0xc3, 0x3a, 0xc0, 0xa4, 0xc3, 0xce, 0x66, 0x66, 0x16, 0xdc, 0x37, 0xe8, 0xa3, 0x79, 0xe9,
	0x23, 0x18, 0x9e, 0xc4, 0x30, 0x0b, 0x05, 0xff, 0xf5, 0xee, 0xf0, 0x9d, 0xdf, 0x77, 0x38, 0xe7,
	0x9b, 0x2c, 0xd4, 0xe8, 0x37, 0x4d, 0x23, 0xc5, 0x44, 0xa4, 0xdc, 0x59, 0x8b, 0xf0, 0x78, 0x42,
	0x5a, 0xee, 0x9c, 0xa8, 0x29, 0x8e, 0xa5, 0xd0, 0x02, 0x3d, 0x62, 0x4a, 0x33, 0x81, 0x37, 0x14,
	0x5e, 0x53, 0x87, 0xb5, 0xb1, 0x10, 0x63, 0x4e, 0x5d, 0x03, 0x0e, 0x93, 0x91, 0x3b, 0x97, 0x24,
	0x8e, 0xa9, 0x54, 0x99, 0xf5, 0xf0, 0xf1, 0x9f, 0x7d, 0xa5, 0x65, 0x12, 0xea, 0x55, 0xb7, 0xaa,
	0xd3, 0x98, 0xba, 0xb3, 0xd6, 0x90, 0x6a, 0xd2, 0x72, 0x15, 0xe5, 0x34, 0xd4, 0x42, 0x66, 0xcd,
	0xa7, 0x37, 0xbb, 0x00, 0x97, 0x44, 0x4d, 0x3d, 0x9e, 0x8c, 0x59, 0x84, 0xde, 0x43, 0x69, 0x0d,
	0x38, 0x56, 0xdd, 0x6a, 0x54, 0xda, 0xcf, 0x70, 0xb6, 0xd7, 0x72, 0x08, 0x5e, 0x0d, 0xc1, 0x97,
	0x42, 0x5e, 0x73, 0x41, 0xbe, 0x06, 0x2b, 0xd6, 0xbf, 0x75, 0x21, 0x1b, 0xf2, 0x89, 0xe4, 0xce,
	0x4e, 0xdd, 0x6a, 0x94, 0xfd, 0x65, 0x89, 0xaa, 0x50, 0x54, 0x13, 0xd2, 0x7e, 0x73, 0xe4, 0xe4,
	0x97, 0xe2, 0x79, 0xce, 0x5f, 0xfd, 0xbe, 0xb1, 0x2c, 0xf4, 0x19, 0x1e, 0xb0, 0x29, 0x19, 0xd3,
	0x41, 0x9c, 0x70, 0x3e, 0x88, 0x05, 0x67, 0x61, 0xea, 0xec, 0xd6, 0xad, 0xc6, 0xfd, 0xf6, 0x73,
	0xfc, 0xdf, 0x44, 0xb0, 0x97, 0x70, 0xee, 0x19, 0xd8, 0x3f, 0x30, 0xfe, 0x8d, 0x80, 0x9a, 0xbf,
	0x8d, 0x54, 0x34, 0x94, 0x54, 0x3b, 0x05, 0xb3, 0xcf, 0x86, 0x0d, 0x8c, 0x8c, 0x5e, 0x82, 0x3d,
	0xa3, 0x92, 0x8d, 0x58, 0x48, 0x34, 0x13, 0xd1, 0xe0, 0x9a, 0xa6, 0x4e, 0x31, 0x43, 0xb7, 0xf5,
	0x4f, 0x34, 0x45, 0xc7, 0x70, 0x2f, 0x36, 0x21, 0x0d, 0x42, 0x11, 0x8d, 0xd8, 0xd8, 0xd9, 0x33,
	0xf9, 0x3c, 0xc4, 0x59, 0xf8, 0x78, 0x1d, 0x3e, 0x0e, 0x4c, 0xf8, 0xfe, 0x7e, 0x46, 0x9f, 0x1a,
	0x18, 0x3d, 0x81, 0xca, 0xca, 0x1d, 0x91, 0x29, 0x75, 0x4a, 0xe6, 0x3f, 0x20, 0x93, 0x7a, 0x64,
	0x4a, 0xd1, 0x31, 0x14, 0xe2, 0x09, 0x51, 0xd4, 0x29, 0x9b, 0xe3, 0x5f, 0xdc, 0x75, 0xbc, 0x71,
	0x79, 0x4b, 0xda, 0xcf, 0x4c, 0xe8, 0x2d, 0x94, 0x62, 0xc9, 0x84, 0x64, 0x3a, 0x75, 0xc0, 0xec,
	0x55, 0xfd, 0x6b, 0xaf, 0x6e, 0xa4, 0x8f, 0x5e, 0x7f, 0x21, 0x3c, 0xa1, 0xfe, 0x2d, 0x7c, 0x52,
	0x86, 0xbd, 0x41, 0xf6, 0x1a, 0xcd, 0x77, 0x50, 0xd9, 0x9a, 0x8c, 0x0e, 0xa0, 0x72, 0xd1, 0x0b,
	0xbc, 0xb3, 0xd3, 0xee, 0xc7, 0xee, 0xd9, 0x07, 0x3b, 0x87, 0xca, 0x50, 0xe8, 0x5c, 0xf4, 0xcf,
	0x7b, 0xb6, 0xb5, 0x2e, 0xaf, 0xec, 0x9d, 0x65, 0x19, 0xf4, 0x3b, 0xfd, 0xc0, 0xce, 0x37, 0x9b,
	0x00, 0x5b, 0xcf, 0x60, 0xc3, 0x7e, 0x77, 0xd4, 0x13, 0xda, 0x93, 0x54, 0xd1, 0x48, 0xdb, 0x39,
	0x04, 0x50, 0xec, 0xf0, 0x39, 0x49, 0x95, 0x6d, 0x9d, 0xe0, 0xef, 0x8b, 0x9a, 0xf5, 0x63, 0x51,
	0xb3, 0x7e, 0x2e, 0x6a, 0xd6, 0x55, 0x3d, 0x3b, 0x96, 0x09, 0x97, 0xc4, 0xcc, 0xfd, 0xc7, 0x87,
	0x32, 0x2c, 0x9a, 0x33, 0x5e, 0xfd, 0x0a, 0x00, 0x00, 0xff, 0xff, 0xa9, 0x5f, 0x94, 0xc2, 0x46,
	0x03, 0x00, 0x00,
}

func (m *WasmPlugin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WasmPlugin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WasmPlugin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Priority != nil {
		{
			size, err := m.Priority.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWasm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Phase != 0 {
		i = encodeVarintWasm(dAtA, i, uint64(m.Phase))
		i--
		dAtA[i] = 0x48
	}
	if len(m.PluginName) > 0 {
		i -= len(m.PluginName)
		copy(dAtA[i:], m.PluginName)
		i = encodeVarintWasm(dAtA, i, uint64(len(m.PluginName)))
		i--
		dAtA[i] = 0x42
	}
	if m.PluginConfig != nil {
		{
			size, err := m.PluginConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWasm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.VerificationKey) > 0 {
		i -= len(m.VerificationKey)
		copy(dAtA[i:], m.VerificationKey)
		i = encodeVarintWasm(dAtA, i, uint64(len(m.VerificationKey)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ImagePullSecret) > 0 {
		i -= len(m.ImagePullSecret)
		copy(dAtA[i:], m.ImagePullSecret)
		i = encodeVarintWasm(dAtA, i, uint64(len(m.ImagePullSecret)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ImagePullPolicy != 0 {
		i = encodeVarintWasm(dAtA, i, uint64(m.ImagePullPolicy))
		i--
		dAtA[i] = 0x20
	}
	if m.XSha256 != nil {
		{
			size := m.XSha256.Size()
			i -= size
			if _, err := m.XSha256.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintWasm(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x12
	}
	if m.Selector != nil {
		{
			size, err := m.Selector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWasm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WasmPlugin_Sha256) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WasmPlugin_Sha256) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Sha256)
	copy(dAtA[i:], m.Sha256)
	i = encodeVarintWasm(dAtA, i, uint64(len(m.Sha256)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func encodeVarintWasm(dAtA []byte, offset int, v uint64) int {
	offset -= sovWasm(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *WasmPlugin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Selector != nil {
		l = m.Selector.Size()
		n += 1 + l + sovWasm(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovWasm(uint64(l))
	}
	if m.XSha256 != nil {
		n += m.XSha256.Size()
	}
	if m.ImagePullPolicy != 0 {
		n += 1 + sovWasm(uint64(m.ImagePullPolicy))
	}
	l = len(m.ImagePullSecret)
	if l > 0 {
		n += 1 + l + sovWasm(uint64(l))
	}
	l = len(m.VerificationKey)
	if l > 0 {
		n += 1 + l + sovWasm(uint64(l))
	}
	if m.PluginConfig != nil {
		l = m.PluginConfig.Size()
		n += 1 + l + sovWasm(uint64(l))
	}
	l = len(m.PluginName)
	if l > 0 {
		n += 1 + l + sovWasm(uint64(l))
	}
	if m.Phase != 0 {
		n += 1 + sovWasm(uint64(m.Phase))
	}
	if m.Priority != nil {
		l = m.Priority.Size()
		n += 1 + l + sovWasm(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WasmPlugin_Sha256) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sha256)
	n += 1 + l + sovWasm(uint64(l))
	return n
}

func sovWasm(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozWasm(x uint64) (n int) {
	return sovWasm(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *WasmPlugin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWasm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WasmPlugin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WasmPlugin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWasm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWasm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWasm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Selector == nil {
				m.Selector = &v1beta1.WorkloadSelector{}
			}
			if err := m.Selector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWasm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWasm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWasm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sha256", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWasm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWasm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWasm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XSha256 = &WasmPlugin_Sha256{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePullPolicy", wireType)
			}
			m.ImagePullPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWasm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImagePullPolicy |= PullPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePullSecret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWasm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWasm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWasm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImagePullSecret = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerificationKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWasm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWasm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWasm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerificationKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PluginConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWasm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWasm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWasm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PluginConfig == nil {
				m.PluginConfig = &types.Struct{}
			}
			if err := m.PluginConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PluginName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWasm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWasm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWasm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PluginName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			m.Phase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWasm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Phase |= PluginPhase(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWasm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWasm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWasm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Priority == nil {
				m.Priority = &types.Int64Value{}
			}
			if err := m.Priority.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWasm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWasm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipWasm(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowWasm
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWasm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWasm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthWasm
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupWasm
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthWasm
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthWasm        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowWasm          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupWasm = fmt.Errorf("proto: unexpected end of group")
)
